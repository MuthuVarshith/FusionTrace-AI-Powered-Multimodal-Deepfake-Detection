# -*- coding: utf-8 -*-
"""Image_detection_dataset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bMCDdNsypdYegreVOmzK3g3PALtedhgH
"""

# %pip install efficientnet-pytorch

import os
import numpy as np
import pandas as pd
import torch
import torchvision.transforms as transforms
from torch.utils.data import DataLoader, Dataset
from torchvision import models
import torch.nn as nn
import torch.optim as optim
from sklearn.metrics import classification_report, confusion_matrix, ConfusionMatrixDisplay
from PIL import Image
from efficientnet_pytorch import EfficientNet  # Import EfficientNet

# Commented out IPython magic to ensure Python compatibility.
# %pip install kaggle

#!/bin/bash
!kaggle datasets download alaaeddineayadi/real-vs-ai-generated-faces

#!/bin/bash
!kaggle datasets download xhlulu/140k-real-and-fake-faces

!unzip 140k-real-and-fake-faces.zip

!unzip real-vs-ai-generated-faces.zip

from pathlib import Path

# Specify the directory you want to check
directory_path = Path('real_vs_fake')  # Replace with your directory name

# Print the subdirectories and files
for item in directory_path.iterdir():
    if item.is_dir():
        print(f"Directory: {item.name}")
    else:
        print(f"File: {item.name}")

from pathlib import Path

# Specify the directory to check
directory_path = Path('real_vs_fake')  # Replace with your directory name

# Function to print directory tree without files
def print_directory_tree(path, indent=0):
    for item in path.iterdir():
        # Only print if the item is a directory
        if item.is_dir():
            print(' ' * indent + f"__ {item.name}")  # Use + to indicate a directory
            # Recursively print its subdirectories
            print_directory_tree(item, indent + 4)

# Call the function
print_directory_tree(directory_path)

from pathlib import Path

# Specify the directory to check
directory_path = Path('dataset')  # Replace with your directory name

# Function to print directory tree without files
def print_directory_tree(path, indent=0):
    for item in path.iterdir():
        # Only print if the item is a directory
        if item.is_dir():
            print(' ' * indent + f"__ {item.name}")  # Use + to indicate a directory
            # Recursively print its subdirectories
            print_directory_tree(item, indent + 4)

# Call the function
print_directory_tree(directory_path)

import os

def count_images(directory):
    count_dict = {}
    for root, dirs, files in os.walk(directory):
        if files:
            count_dict[root] = len([f for f in files if f.lower().endswith(('jpg', 'jpeg', 'png'))])
    return count_dict

def print_counts(count_dict, dataset_name):
    print(f"\nDataset: {dataset_name}")
    print("-" * 50)
    for folder, count in sorted(count_dict.items()):
        print(f"{folder}: {count} images")

# Paths to your datasets
dataset_1_path = "dataset"
dataset_2_path = "real_vs_fake"

# Counting images
dataset_1_counts = count_images(dataset_1_path)
dataset_2_counts = count_images(dataset_2_path)

# Displaying results
print_counts(dataset_1_counts, "Dataset 1")
print_counts(dataset_2_counts, "Real vs Fake")

import os
import shutil
from tqdm import tqdm  # Import tqdm for progress bar

# Define source directories
dataset_1_path = "dataset"
dataset_2_path = "real_vs_fake"

# Define destination directory
destination_fake = "DATA/fake"

# Ensure destination directory exists
os.makedirs(destination_fake, exist_ok=True)

# Function to copy all fake images from datasets with tqdm
def merge_fake_images(source_dirs, destination):
    all_images = []

    # Collect all fake image paths
    for folder in source_dirs:
        fake_path = os.path.join(folder, "fake")
        if os.path.exists(fake_path):
            images = [os.path.join(fake_path, img) for img in os.listdir(fake_path)]
            all_images.extend(images)

    # Copy images with progress bar
    for src in tqdm(all_images, desc="Copying fake images", unit="file"):
        dst = os.path.join(destination, os.path.basename(src))
        shutil.copy2(src, dst)  # Copy with metadata

# Define paths to fake image folders
fake_folders = [
    os.path.join(dataset_1_path, "train"),
    os.path.join(dataset_1_path, "test"),
    os.path.join(dataset_1_path, "val"),
    os.path.join(dataset_2_path, "real-vs-fake/train"),
    os.path.join(dataset_2_path, "real-vs-fake/test"),
    os.path.join(dataset_2_path, "real-vs-fake/valid")
]

# Merge fake images with progress bar
merge_fake_images(fake_folders, destination_fake)

print("\nAll fake images have been merged into:", destination_fake)

import os
import shutil
from tqdm import tqdm  # Import tqdm for progress bar

# Define source directories
dataset_1_path = "dataset"
dataset_2_path = "real_vs_fake"

# Define destination directory for real images
destination_real = "DATA/real"

# Ensure destination directory exists
os.makedirs(destination_real, exist_ok=True)

# Function to copy all real images with tqdm progress bar
def merge_real_images(source_dirs, destination):
    all_images = []

    # Collect all real image paths
    for folder in source_dirs:
        real_path = os.path.join(folder, "real")
        if os.path.exists(real_path):
            images = [os.path.join(real_path, img) for img in os.listdir(real_path)]
            all_images.extend(images)

    # Copy images with progress bar
    for src in tqdm(all_images, desc="Copying real images", unit="file"):
        dst = os.path.join(destination, os.path.basename(src))
        shutil.copy2(src, dst)  # Copy with metadata

# Define paths to real image folders
real_folders = [
    os.path.join(dataset_1_path, "train"),
    os.path.join(dataset_1_path, "test"),
    os.path.join(dataset_1_path, "val"),
    os.path.join(dataset_2_path, "real-vs-fake/train"),
    os.path.join(dataset_2_path, "real-vs-fake/test"),
    os.path.join(dataset_2_path, "real-vs-fake/valid")
]

# Merge real images with progress bar
merge_real_images(real_folders, destination_real)

print("\nAll real images have been merged into:", destination_real)

import os

# Define paths to merged fake and real image folders
data_path = "DATA"
folders = ["fake", "real"]

# Function to count images in a folder
def count_images(folder_path):
    return len([img for img in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, img))]) if os.path.exists(folder_path) else 0

# Print the total image count for each category
print("\nMerged Dataset in DATA Folder")
print("-" * 50)

for folder in folders:
    folder_path = os.path.join(data_path, folder)
    image_count = count_images(folder_path)
    print(f"{folder_path}: {image_count} images")

import os
import random

# Define paths
real_folder = "DATA/real"
target_count = 75000  # Target image count to match DATA/fake

# Get all images in the real folder
all_images = [img for img in os.listdir(real_folder) if os.path.isfile(os.path.join(real_folder, img))]

# Calculate how many images to remove
extra_images = len(all_images) - target_count

if extra_images > 0:
    print(f"Removing {extra_images} extra images from {real_folder}...")

    # Randomly select images to remove
    images_to_remove = random.sample(all_images, extra_images)

    # Delete selected images
    for img in images_to_remove:
        os.remove(os.path.join(real_folder, img))

    print(f"Successfully reduced {real_folder} to {target_count} images.")
else:
    print(f"No extra images to remove. {real_folder} already has {target_count} or fewer images.")

import os

# Define paths to merged fake and real image folders
data_path = "DATA"
folders = ["fake", "real"]

# Function to count images in a folder
def count_images(folder_path):
    return len([img for img in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, img))]) if os.path.exists(folder_path) else 0

# Print the total image count for each category
print("\nMerged Dataset in DATA Folder")
print("-" * 50)

for folder in folders:
    folder_path = os.path.join(data_path, folder)
    image_count = count_images(folder_path)
    print(f"{folder_path}: {image_count} images")

